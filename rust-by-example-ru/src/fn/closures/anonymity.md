# Анонимность типов

Замыкания временно захватывают переменные из окружающих областей видимости.
Имеет ли это какие-либо последствия? Конечно. Как видите, использование
замыкания в аргументах функции требует [обобщённых типов](generics.html) из-за
особенностей реализации замыканий:

```rust
// `F` должен быть обобщённым типом.
fn apply<F>(f: F) where
    F: FnOnce() {
    f();
}
```

Во время определения замыкания компилятор неявно создаёт новую анонимную
структуру для хранения захваченных переменных, тем временем реализуя
функциональность для некого неизвестного типа с помощью одного из типажей: `Fn`,
`FnMut`, или `FnOnce`. Этот тип присваивается переменной, которая хранится до
самого вызова замыкания.

Так как этот новый тип заранее неизвестен, любое его использование в функции
потребует обобщённых типов. Тем не менее, неограниченный параметр типа `<T>`
по прежнему будет неоднозначным и недопустим. Таким образом, ограничение по
одному из типажей: `Fn`, `FnMut`, или `FnOnce` (которые он реализует) необходимо
для использования этого типа.

```rust,editable
// `F` должен реализовать `Fn` для замыкания, которое
// ничего не принимает и не возвращает - именно то,
// что нужно для `print`.
fn apply<F>(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Захватываем `x` в анонимный тип и реализуем
    // `Fn` для него. Сохраняем его как `print`.
    let print = || println!("{}", x);

    apply(print);
}
```

### Смотрите также:

[Подробный разбор](https://huonw.github.io/blog/2015/05/finding-closure-in-rust/), [`Fn`](https://doc.rust-lang.org/std/ops/trait.Fn.html), [`FnMut`](https://doc.rust-lang.org/std/ops/trait.FnMut.html),
и [`FnOnce`](https://doc.rust-lang.org/std/ops/trait.FnOnce.html)
