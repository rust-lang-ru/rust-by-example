# Литералы и операторы

Целочисленное `1`, вещественное `1.2`, символ `'a'`, строка `"abc"`, логическое `true`
и единичный тип `()` могут быть выражены с помощью литералов.

Целочисленные значения так же могут быть выражены с помощью шестнадцатеричного,
восьмеричного или двоичного обозначения используя соответствующие префиксы: `0x`, `0o` или `0b`.

Для улучшения читаемости числовых литералов можно использовать подчёркивания, например
`1_000` тоже самое, что и `1000`, и `0.000_001` равно `0.000001`.

Нам необходимо указать компилятору какой тип для литерала мы используем.
Сейчас мы используем суффикс `u32`, чтобы указать, что литерал - беззнаковое целое
число 32-х бит и суффикс `i32` - знаковое целое 32-х битное число.

Доступные операторы и их приоритет [в Rust][rust op-prec] такой же как и в других
[C-подобных языках][op-prec].

```rust,editable
fn main() {
    // Целочисленное сложение
    println!("1 + 2 = {}", 1u32 + 2);

    // Целочисленное вычитание
    println!("1 - 2 = {}", 1i32 - 2);
    // ЗАДАНИЕ ^ Попробуйте изменить `1i32` на `1u32`
    // чтобы убедится насколько важен тип данных

    // Булева логика
    println!("true И false будет {}", true && false);
    println!("true ИЛИ false будет {}", true || false);
    println!("НЕ true будет {}", !true);

    // Побитовые операции
    println!("0011 И 0101 будет {:04b}", 0b0011u32 & 0b0101);
    println!("0011 ИЛИ 0101 будет {:04b}", 0b0011u32 | 0b0101);
    println!("0011 исключающее ИЛИ 0101 будет {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 будет {}", 1u32 << 5);
    println!("0x80 >> 2 будет 0x{:x}", 0x80u32 >> 2);

    // Использование подчёркивания для улучшения читаемости!
    println!("Один миллион записан как {}", 1_000_000u32);
}
```

[rust op-prec]: https://doc.rust-lang.org/reference/expressions.html#expression-precedence
[op-prec]: https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages
